=======================================================================================================================================================
模式的问题：
	你如何能轻松方便地构造对象实例，而不必关心构造对象实例的细节和复杂过程呢？
解决方案：
	建立一个工厂来创建对象
=======================================================================================================================================================
分类：工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。 
工厂模式可以分为三类： 
	1）简单工厂模式（Simple Factory） 
	2）工厂方法模式（Factory Method） 
	3）抽象工厂模式（Abstract Factory） 
这三种模式从上到下逐步抽象，并且更具一般性。 
	GOF在《设计模式》一书中将工厂模式分为两类：工厂方法模式（Factory Method）与抽象工厂模式（Abstract Factory）。
	将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。 
=======================================================================================================================================================
区别 
工厂方法模式：
	一个抽象产品类，可以派生出多个具体产品类。   
	一个抽象工厂类，可以派生出多个具体工厂类。   
	每个具体工厂类只能创建一个具体产品类的实例。
抽象工厂模式：
	多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。   
	一个抽象工厂类，可以派生出多个具体工厂类。   
	每个具体工厂类可以创建多个具体产品类的实例。   
区别：
	工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。   
	工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。
	两者皆可。
=======================================================================================================================================================
总结：
	无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。
	在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。
	经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；
而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。
	所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。
=======================================================================================================================================================